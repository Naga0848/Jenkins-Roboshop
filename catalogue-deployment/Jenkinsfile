pipeline {
    agent {
        label 'AGENT-1'  // this is the Label which we mentioned while configuring the Jenkins agent and this pipeline gets exected, when these both the values match
    }
     environment {
        appVersion = ''
        REGION = "us-east-1"
        ACC_ID = "324512687633"
        PROJECT = "roboshop"
        COMPONENT = "catalogue"
     }
     options {
            timeout(time: 30, unit: 'MINUTES')  // this shows max time to run a pipeline
            disableConcurrentBuilds()   // this disables the parallel builds and used mostly in PROD pipelines
            ansiColor('xterm')   // to enable the colurs in the console output
             }  
     parameters {
        string(name: 'appVersion', description: 'Image version of the application')  // version of the image
        choice(name: 'deploy_to', choices: ['dev', 'qa', 'prod'], description: 'Pick the Environment')  // this displays in which env we are deploying
                }        
    stages {
        stage('Deploy') {  // this stage is to deploy into K8s
            steps {
                script {
                    dir('catalogue-deployment')  // line no-30&31 These commands replace the placeholder IMAGE_VERSION in the environment-specific Helm values file with the given application version, then perform a Helm upgrade (or install if not already deployed) of the specified component into the target Kubernetes namespace using that updated values file.
                    withAWS(credentials: 'aws-creds', region: 'us-east-1') {  // kubectl must be installed on Jenkins Agent and AWS creds must be configured in Jenkins Master
                        sh """
                            aws eks update-kubeconfig --region $REGION --name "$PROJECT-${params.deploy_to}"
                            kubectl get nodes
                            sed -i "s/IMAGE_VERSION/${params.appVersion}/g" values-${params.deploy_to}.yaml   
                            helm upgrade --install $COMPONENT -f values-${params.deploy_to}.yaml -n $PROJECT . 
                        """
                    }

                }
            }
        }
        stage('Docker Build') { // what ever we mentioned inside this stage are the commmands given in the AWS ECR itself, but we have to modify little according to our project
            steps {
                script {
                    dir('catalogue'){
                    withAWS(credentials: 'aws-creds', region: 'us-east-1') {
                sh """
                    aws ecr get-login-password --region ${REGION} | docker login --username AWS --password-stdin ${ACC_ID}.dkr.ecr.us-east-1.amazonaws.com
                    docker build -t ${ACC_ID}.dkr.ecr.us-east-1.amazonaws.com/${PROJECT}/${COMPONENT}:${appVersion} .
                    docker push ${ACC_ID}.dkr.ecr.us-east-1.amazonaws.com/${PROJECT}/${COMPONENT}:${appVersion}
                    #aws ecr wait image-scan-complete --repository-name ${PROJECT}/${COMPONENT} --image-id imageTag=${appVersion} --region ${REGION}
                """
                }
                    }  
                }
            }
        }
    }
}